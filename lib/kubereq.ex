defmodule Kubereq do
  @moduledoc ~S"""
  Kubereq defines a set of Request Steps for `Req`. All steps combined turn
  a Kubernetes configuration in the form of a `%Kubereq.Kubeconfig{}` struct into a
  `%Req.Request{}` struct containing all headers and options required to
  connect to the cluster and perform the given operations.

  In order to build `%Kubereq.Kubeconfig{}` struct you can either use the steps defined
  in the `Kubeconf` library or create your own Kubernetes configuration loader
  module combining those steps.

  Instead of using this module directly, consider using
  [`Kubegen`](https://github.com/mruoss/kubegen) to generate your API clients.

  ### Examples

  The following is a simple but incomplete example for a Client dealing
  with ConfigMaps. This code is an extraction of what is generated by
  [`Kubegen`](https://github.com/mruoss/kubegen) when generating a client for
  ConfigMaps.

      defmodule MyApp.K8sClient.Core.V1.ConfigMap do
        @resource_path "api/v1/namespaces/:namespace/configmaps/:name"

        defp req() do
          kubeconfig = Kubereq.Kubeconfig.load(Kubereq.Kubeconfig.Default)
          Kubereq.new(kubeconfig, @resource_path)
        end

        def get(namespace, name) do
          Kubereq.get(req(), namespace, name)
        end

        def list(namespace, opts \\ []) do
          Kubereq.list(req(), namespace, opts \\ [])
        end
      end
  """

  require Logger

  alias Kubereq.Step

  @type wait_until_callback :: (map() | :deleted -> boolean | {:error, any})
  @type wait_until_response :: :ok | {:error, :watch_timeout}
  @type response() :: {:ok, Req.Response.t()} | {:error, Exception.t()}
  @type namespace() :: String.t() | nil
  @type subresource() :: String.t() | nil
  @type watch_response :: {:ok, Enumerable.t(map())} | {:ok, Task.t()} | {:error, Exception.t()}
  @typep do_watch_response :: {:ok, Enumerable.t(map())} | {:error, Exception.t()}

  @doc """
  Prepares a `Req.Request` struct for making HTTP requests to a Kubernetes
  cluster.

  ### Options

  * `:kubeconfig` - Kubernetes configuration in the form of a
  `%Kubereq.Kubeconfig{}` struct. It should contain all informations required to
  connect to the Kubernetes cluster.
  * `:resource_path` - The path on to the targeted resource endpoint. It should
  contain placeholders for `:namespace` and `:name`.

  ### Examples

      iex> Kubereq.new()
      %Request.Req{...}

  Passing a kubeconfig loader pipeline

      iex> Kubereq.new(kubeconfig: Kubereq.Kubeconfig.Default)
      %Request.Req{...}

  Passing a pre-loaded Kubeconfig

      iex> kubeconfig = Kubereq.Kubeconfig.load(Kubereq.Kubeconfig.Default)
      ...> Kubereq.new(kubeconfig: kubeconfig)
      %Request.Req{...}

  Passing `:kubeconfig` and `:resource_path`

      iex> Kubereq.new(kubeconfig: Kubereq.Kubeconfig.Default, resource_path: "api/v1/namespaces/:namespace/configmaps/:name")
      %Request.Req{...}
  """
  @spec new(opts :: Keyword.t()) :: Req.Request.t()
  def new(opts \\ []) do
    options =
      opts
      |> Keyword.put_new(:kubeconfig, Kubereq.Kubeconfig.Default)
      |> Keyword.update!(:kubeconfig, fn
        %Kubereq.Kubeconfig{} = kubeconfig -> kubeconfig
        pipeline -> Kubereq.Kubeconfig.load(pipeline)
      end)

    Req.new()
    |> Req.Request.register_options([:kubeconfig])
    |> Step.FieldSelector.attach()
    |> Step.LabelSelector.attach()
    |> Step.Compression.attach()
    |> Step.TLS.attach()
    |> Step.Auth.attach()
    |> Step.Impersonate.attach()
    |> Step.Operation.attach()
    |> Step.Plug.attach()
    |> Req.merge(options)
  end

  @doc """
  Create the `resource` or its `subresource` on the cluster.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Example

      iex> Kubereq.create(req, resource)
      {:ok, %Req.Response{status: 201, body: %{...}}}
  """
  @spec create(Req.Request.t(), resource :: map(), opts :: Keyword.t()) :: response()
  def create(req, resource, opts \\ []) do
    options =
      Keyword.merge(opts,
        operation: :create,
        json: resource,
        path_params: [
          namespace: resource["metadata"]["namespace"],
          name: resource["metadata"]["name"]
        ]
      )

    Req.request(req, options)
  end

  @doc """
  Get the resource `name` in `namespace` or its `subresource`.
  The `req` struct should have been created using `Kubereq.new/1`.

  Omit `namespace` to get cluster resources.

  ### Example

      iex> Kubereq.get(req, "default", "foo")
      {:ok, %Req.Response{status: 200, body: %{...}}}
  """
  @spec get(
          Req.Request.t(),
          opts :: Keyword.t()
        ) ::
          response()
  def get(req, namespace, name, opts) do
    options =
      Keyword.merge(opts, operation: :get, path_params: [namespace: namespace, name: name])

    Req.request(req, options)
  end

  def get(req, name), do: get(req, nil, name, [])
  def get(req, namespace, name) when is_binary(name), do: get(req, namespace, name, [])
  def get(req, name, opts) when is_list(opts), do: get(req, nil, name, [])

  @doc """
  Get a resource list.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.list(req, "default", [])
      {:ok, %Req.Response{status: 200, body: %{...}}}

  ### Options

  * `:field_selectors` - A list of field selectors. See `Kubereq.Step.FieldSelector` for more infos.
  * `:label_selectors` - A list of field selectors. See `Kubereq.Step.LabelSelector` for more infos.
  """
  @spec list(Req.Request.t(), namespace :: namespace(), opts :: keyword()) ::
          response()
  def list(req, namespace, opts) do
    Req.get(req,
      operation: :list,
      field_selectors: opts[:field_selectors],
      label_selectors: opts[:label_selectors],
      path_params: [namespace: namespace]
    )
  end

  def list(req), do: list(req, nil, [])
  def list(req, namespace) when is_binary(namespace), do: list(req, namespace, [])
  def list(req, opts) when is_list(opts), do: list(req, nil, opts)

  @doc """
  Deletes the `resource` or its `subresource` from the cluster.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.delete(req, "default", "foo")
      {:ok, %Req.Response{status: 200, body: %{...}}}
  """
  @spec delete(
          Req.Request.t(),
          namespace :: namespace(),
          name :: String.t(),
          opts :: Keyword.t()
        ) ::
          response()
  def delete(req, namespace, name, opts) do
    options =
      Keyword.merge(opts, operation: :delete, path_params: [namespace: namespace, name: name])

    Req.request(req, options)
  end

  def delete(req, name), do: delete(req, nil, name, [])
  def delete(req, namespace, name) when is_binary(name), do: delete(req, namespace, name, [])
  def delete(req, name, opts) when is_list(opts), do: delete(req, nil, name, opts)

  @doc """
  Deletes all resources in the given namespace.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.delete_all(req, "default", "foo")
      {:ok, %Req.Response{...}

  ### Options

  * `:field_selectors` - A list of field selectors. See `Kubereq.Step.FieldSelector` for more infos.
  * `:label_selectors` - A list of field selectors. See `Kubereq.Step.LabelSelector` for more infos.
  """
  @spec delete_all(Req.Request.t(), namespace :: namespace(), opts :: keyword()) :: response()
  def delete_all(req, namespace, opts) do
    options = Keyword.merge(opts, operation: :delete_all, path_params: [namespace: namespace])
    Req.request(req, options)
  end

  def delete_all(req), do: delete_all(req, nil, [])
  def delete_all(req, namespace) when is_binary(namespace), do: delete_all(req, namespace, [])
  def delete_all(req, opts) when is_list(opts), do: delete_all(req, nil, opts)

  @doc """
  Updates the given `resource`.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.update(req, %{...})
      {:ok, %Req.Response{...}
  """
  @spec update(Req.Request.t(), resource :: map(), opts :: Keyword.t()) :: response()
  def update(req, resource, opts \\ []) do
    options =
      Keyword.merge(opts,
        operation: :update,
        json: resource,
        path_params: [
          namespace: get_in(resource, ~w(metadata namespace)),
          name: get_in(resource, ~w(metadata name))
        ]
      )

    Req.request(req, options)
  end

  @doc """
  Applies the given `resource` using a Server-Side-Apply Patch.
  The `req` struct should have been created using `Kubereq.new/1`.

  See the [documentation](https://kubernetes.io/docs/reference/using-api/server-side-apply/)
  for a documentation on `field_manager` and `force` arguments.

  ### Examples

      iex> Kubereq.apply(req, %{...})
      {:ok, %Req.Response{...}
  """
  @spec apply(
          Req.Request.t(),
          resource :: map(),
          field_manager :: binary(),
          force :: boolean(),
          opts :: Keyword.t()
        ) :: response()
  def apply(req, resource, field_manager, force, opts) do
    options =
      Keyword.merge(opts,
        operation: :apply,
        path_params: [
          namespace: get_in(resource, ~w(metadata namespace)),
          name: get_in(resource, ~w(metadata name))
        ],
        params: [fieldManager: field_manager, force: force],
        json: resource
      )

    Req.request(req, options)
  end

  def apply(req, resource, opts \\ []), do: apply(req, resource, "Elixir", true, opts)

  def apply(req, resource, field_manager, force) do
    apply(req, resource, field_manager, force, [])
  end

  @doc """
  Patches the resource `name`in `namespace` or its `subresource` using the given
  `json_patch`. The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.json_patch(req, %{...}, "default", "foo")
      {:ok, %Req.Response{...}
  """
  @spec json_patch(
          Req.Request.t(),
          json_patch :: map(),
          namespace :: namespace(),
          name :: String.t(),
          opts :: Keyword.t()
        ) :: response()
  def json_patch(req, json_patch, namespace, name, opts) do
    options =
      Keyword.merge(opts,
        operation: :json_patch,
        path_params: [namespace: namespace, name: name],
        json: json_patch
      )

    Req.request(req, options)
  end

  def json_patch(req, json_patch, name), do: json_patch(req, json_patch, nil, name, [])

  def json_patch(req, json_patch, namespace, name) when is_binary(name) do
    json_patch(req, json_patch, namespace, name, [])
  end

  def json_patch(req, json_patch, name, opts) when is_list(opts) do
    json_patch(req, json_patch, nil, name, opts)
  end

  @doc """
  Patches the resource `name`in `namespace` or its `subresource` using the given
  `merge_patch`. The `req` struct should have been created using
  `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.merge_patch(req, %{...}, "default", "foo")
      {:ok, %Req.Response{...}
  """
  @spec merge_patch(
          Req.Request.t(),
          merge_patch :: String.t(),
          namespace :: namespace(),
          name :: String.t(),
          opts :: Keyword.t()
        ) :: response()
  def merge_patch(req, merge_patch, namespace, name, opts) do
    options =
      Keyword.merge(opts,
        operation: :merge_patch,
        path_params: [namespace: namespace, name: name],
        json: merge_patch
      )

    Req.request(req, options)
  end

  def merge_patch(req, merge_patch, name), do: merge_patch(req, merge_patch, nil, name, [])

  def merge_patch(req, merge_patch, namespace, name) when is_binary(name) do
    merge_patch(req, merge_patch, namespace, name, [])
  end

  def merge_patch(req, merge_patch, name, opts) when is_list(opts) do
    merge_patch(req, merge_patch, nil, name, opts)
  end

  @doc """
  GET a resource and wait until the given `callback` returns true or the given
  `timeout` (ms) has expired.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Options

  * `timeout` - Timeout in ms after function terminates with `{:error, :timeout}`
  """
  @spec wait_until(
          Req.Request.t(),
          namespace :: namespace(),
          name :: String.t(),
          callback :: wait_until_callback(),
          timeout :: non_neg_integer()
        ) :: wait_until_response()
  def wait_until(req, namespace, name, callback, timeout) do
    ref = make_ref()
    opts = [field_selectors: [{"metadata.name", name}], stream_to: {self(), ref}]

    with {:ok, resp} <- list(req, namespace, opts),
         {:init, false} <- {:init, callback.(List.first(resp.body["items"]) || :deleted)} do
      {:ok, watch_task} =
        watch(
          req,
          namespace,
          Keyword.put(opts, :resource_version, resp.body["metadata"]["resourceVersion"])
        )

      timer = Process.send_after(self(), {ref, :timeout}, timeout)
      result = wait_event_loop(ref, callback)
      Task.shutdown(watch_task)
      Process.cancel_timer(timer)
      result
    else
      {:init, true} -> :ok
      {:init, {:error, error}} -> {:error, error}
      {:error, error} -> {:error, error}
    end
  end

  def wait_until(req, name, callback), do: wait_until(req, name, nil, callback, 10_000)

  def wait_until(req, name, namespace, callback) when is_function(callback) do
    wait_until(req, name, namespace, callback, 10_000)
  end

  def wait_until(req, name, callback, timeout) do
    wait_until(req, name, nil, callback, timeout)
  end

  defp wait_event_loop(ref, callback) do
    receive do
      {^ref, %{"type" => "DELETED"}} ->
        case callback.(:deleted) do
          true -> :ok
          false -> :ok
          :ok -> :ok
          {:error, error} -> {:error, error}
        end

      {^ref, %{"object" => resource}} ->
        if callback.(resource), do: :ok, else: wait_event_loop(ref, callback)

      {^ref, :timeout} ->
        {:error, :watch_timeout}
    end
  end

  @doc """
  Watch events of all resources in `namespace`.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.watch(req, "default", [])
      {:ok, #Function<60.48886818/2 in Stream.transform/3>}

  In order to watch events in all namespaces, pass `nil` as namespace:

      iex> Kubereq.watch(req, nil, [])
      {:ok, #Function<60.48886818/2 in Stream.transform/3>}

  ### Options

  * `:resource_version` - If given, starts to stream from the given `resourceVersion` of the resource list. Otherwise starts streaming from HEAD.
  * `:stream_to` - If set to a `pid`, streams events to the given pid. If set to `{pid, ref}`, the messages are in the form `{ref, event}`.
  * `:field_selectors` - A list of field selectors. See `Kubereq.Step.FieldSelector` for more infos.
  * `:label_selectors` - A list of field selectors. See `Kubereq.Step.LabelSelector` for more infos.
  """
  @spec watch(
          Req.Request.t(),
          namespace :: namespace(),
          opts :: keyword()
        ) ::
          watch_response()
  def watch(req, namespace, opts) do
    resource_version = opts[:resource_version]
    do_watch = fn -> do_watch(req, namespace, resource_version, opts) end

    case opts[:stream_to] do
      nil ->
        do_watch.()

      {pid, ref} ->
        task = watch_create_task(do_watch, &send(pid, {ref, &1}))
        {:ok, task}

      pid ->
        task = watch_create_task(do_watch, &send(pid, &1))
        {:ok, task}
    end
  end

  def watch(req), do: watch(req, nil, [])
  def watch(req, namespace) when is_binary(namespace), do: watch(req, namespace, [])
  def watch(req, opts) when is_list(opts), do: watch(req, nil, opts)

  @doc """
  Watch events of a single resources `name`in `namespace`.
  The `req` struct should have been created using `Kubereq.new/1`.

  ### Examples

      iex> Kubereq.watch_single(req, "default", [])
      {:ok, #Function<60.48886818/2 in Stream.transform/3>}

  In order to watch events in all namespaces, pass `nil` as namespace:

      iex> Kubereq.watch_single(req, nil, [])
      {:ok, #Function<60.48886818/2 in Stream.transform/3>}

  ### Options

  * `:stream_to` - If set to a `pid`, streams events to the given pid. If set to `{pid, ref}`, the messages are in the form `{ref, event}`

  """
  @spec watch_single(
          Req.Request.t(),
          namespace :: namespace(),
          name :: String.t()
        ) ::
          watch_response()
  @spec watch_single(
          Req.Request.t(),
          namespace :: namespace(),
          name :: String.t(),
          opts :: keyword()
        ) :: watch_response()
  def watch_single(req, namespace, name, opts) do
    opts = Keyword.put(opts, :field_selectors, [{"metadata.name", name}])
    watch(req, namespace, opts)
  end

  def watch_single(req, name), do: watch_single(req, nil, name, [])

  def watch_single(req, namespace, name) when is_binary(namespace) do
    watch_single(req, namespace, name, [])
  end

  def watch_single(req, name, opts) when is_list(opts), do: watch_single(req, nil, name, opts)

  @spec watch_create_task(
          (-> do_watch_response()),
          (map() -> any())
        ) :: Task.t()
  defp watch_create_task(do_watch_callback, send_callback) do
    Task.async(fn ->
      case do_watch_callback.() do
        {:ok, stream} ->
          stream
          |> Stream.map(send_callback)
          |> Stream.run()

        {:error, error} ->
          send_callback.({:error, error})
      end
    end)
  end

  @spec do_watch(
          Req.Request.t(),
          namespace :: namespace(),
          resource_version :: integer() | String.t(),
          opts :: keyword()
        ) :: do_watch_response()
  defp do_watch(req, namespace, nil, opts) do
    with {:ok, resp} <- list(req, namespace, opts) do
      resource_version = resp.body["metadata"]["resourceVersion"]
      do_watch(req, namespace, resource_version, opts)
    end
  end

  defp do_watch(req, namespace, resource_version, opts) do
    with {:ok, resp} <-
           Req.get(req,
             url: req.options.resource_list_path,
             field_selectors: opts[:field_selectors],
             label_selectors: opts[:label_selectors],
             path_params: [namespace: namespace],
             receive_timeout: :infinity,
             into: :self,
             params: [
               watch: "1",
               allowWatchBookmarks: "1",
               resourceVersion: resource_version
             ]
           ) do
      stream =
        resp
        |> Kubereq.Watch.create_stream()
        |> Kubereq.Watch.transform_to_objects()

      {:ok, stream}
    end
  end
end
